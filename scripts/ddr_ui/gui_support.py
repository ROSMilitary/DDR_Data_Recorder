#! /usr/bin/python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.24
#  in conjunction with Tcl version 8.6
#    Sep 19, 2019 10:53:08 AM EDT  platform: Linux
#******************************************************************************
#
#"Distribution A: Approved for public release; distribution unlimited. OPSEC #4046"
#
#PROJECT: DDR
#
# PACKAGE         :
# ORIGINAL AUTHOR :
# MODIFIED DATE   :
# MODIFIED BY     :
# REVISION        :
#
# Copyright (c) 2020 DCS Corporation
#
# Unlimited Rights assigned to the U.S. Government
#
# This material may be reproduced by or for the U.S Government pursuant
# to the copyright license under the clause at DFARS 252.227-7013.  This
# notice must appear in all copies of this file and its derivatives.
#******************************************************************************
#
#Copyright (c) 2019-2020 U.S. Federal Government (in countries where recognized)
#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"), to deal in
#the Software without restriction, including without limitation the rights to use,
#copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
#Software, and to permit persons to whom the Software is furnished to do so,
#subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
#IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
#DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
#ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#DEALINGS IN THE SOFTWARE.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import datetime
import json
import time
from time import strftime
import os
from pathlib import Path
import shutil
import sys
import threading
from tkinter import messagebox
import tkinter.ttk as ttk
##import pprint
from ddr_data_recorder.msg import Event
from ddr_data_recorder.msg import TopicStatus
from ddr_data_recorder.msg import TopicsUpdate
import rospy
from std_msgs.msg import String
import gui
##from tkinter import *
from multiprocessing import Process, Manager, Value

SYS_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..',
                                        'dynamic_recording'))
sys.path.insert(1, SYS_PATH)
from TopicParser import TopicParser

## @var _HEALTH_TOPIC_VALID
#  a member variable defining the color of a good state of a health topic
_HEALTH_TOPIC_VALID = "green2"
## @var _HEALTH_TOPIC_INVALID
#  a member variable defining the color of a bad state of a health topic
_HEALTH_TOPIC_INVALID = "OrangeRed"
## @var _HEALTH_TOPIC_NOT_FOUND
#  a member variable defining the color of an unknown state of a health topic
_HEALTH_TOPIC_NOT_FOUND = "yellow"
## @var _HEALTH_TOPICS
#  a member variable which holds a list of publishing health topics
_HEALTH_TOPICS = []
## @var _PUB
#  a member variable for a ROS publisher of /ddr/event topic
_PUB = rospy.Publisher('/ddr/event', Event, queue_size=10)
## @var _PUB1
#  a member variable for a ROS publisher of /ddr/mile_counter topic
_PUB1 = rospy.Publisher('/ddr/mileage_counter_msg', String, queue_size=10)
## @var _PUB2
#  a member variable for a ROS publisher of /ddr/rg/software_versions topic
_PUB2 = rospy.Publisher('/ddr/rg/software_versions', String, queue_size=10)
## @var _PUB3
#  a member variable for a ROS publisher of /ddr/rovisional_topic
_PUB3 = rospy.Publisher('/ddr/provisional_topic', String, queue_size=10)
#  a member variable for a ROS publisher of /ddr/mile_counter topic
_PUB4 = rospy.Publisher('/ddr/timeline/hotkeys', String, queue_size=10)
## @var _INIT_DIR
#  a member variable to hold the home location of where captures are stored
_INIT_DIR = rospy.get_param("/directory")
## @var _DDR_DIR
#  a member variable. Holds the full file path of the captures directory
_DDR_DIR = Path(_INIT_DIR).expanduser()
## @var _XML_PATH
#  a member variable. Holds the path to the kml in dynamic_recording folder
_XML_PATH = SYS_PATH +'/' + rospy.get_param('topicXML')
## @var _TP
#  a member variable. An instance of TopicParser
_TP = TopicParser(_XML_PATH)
## @var _PATH_OF_BAGS
#  a member variable. Holds file path one step up from an individual bag
_PATH_OF_BAGS = ""
## @var _LIST_OF_CAPTURES
#  a member variable. A list of all captures
_LIST_OF_CAPTURES = []
## @var _TOP_LEVEL
#  a member variable. Tkinter var. The top level window of the GUI
_TOP_LEVEL = None
## @var _ROOT
# a member variable. Tkinter root widget
_ROOT = None
## @var _UI
# a member variable. Tkinter var which refers to the GUI itself
_UI = None
#current state of the dictionary that was submitted
_SUBMIT_DICT = {}
## @var _KML
# a member variable. This is the current kml file being worked on
_KML = rospy.get_param("topicXML")
## @var _AUTONOMY_VERSION
# a member variable. The version of AUTONOMY currently deployed
_AUTONOMY_VERSION = ""
## @var _UI_ONE_VERSION
# a member variable. The version of UI_ONE currently being used
_UI_ONE_VERSION = ""
## @var _UI_TWO_VERSION
# a member variable. The version of the UI_TWO being used
_UI_TWO_VERSION = ""
## @var _VENDOR
# a member variable. The vendor being recorded
_VENDOR = ""
## @var _VERSIONS
# a member variable. A dictionary to hold the versioning data
_VERSIONS = {}

manager = Manager()
LOCKED_TIME = manager.dict()
CURR_TIME_DICT = manager.dict()


## Documentation for the init() method
#
#  init is called from gui.py, passing top and gui to initialize the
#  local global variables _UI, _TOP_LEVEL, and _ROOT
#  Loads previously saved captures into respective windows of GUI
#  Set font, column widths and default colors of the treeview in thd GUI
def init(top, gui):
    global _UI, _TOP_LEVEL, _ROOT, CURR_TIME_DICT, _AUTONOMY_VERSION, _UI_ONE_VERSION, \
        _UI_TWO_VERSION, _VENDOR, _VERSIONS, _KML

    _UI = gui
    _TOP_LEVEL = top
    _ROOT = top
    _ROOT.resizable(False, False)
    _UI.path_entry.insert(0, str(_DDR_DIR))
    _TOP_LEVEL.protocol("WM_DELETE_WINDOW", destroy_window)
    poll()
    refresh_records()
    initialize_tree_view()
    populate_hot_key_events()
    proc1 = Process(target=update_curr_time, args=(CURR_TIME_DICT,))
    proc1.start()
    input_kml_filename()
    populate_all_modes_scrollbox()

## Documentation for destroy_window() method.
#
#  Method clean kills GUI window  when closing window using 'X' button
#  and also shuts down window with ctrl-c
def destroy_window():
    # Function which closes the window.
    global _TOP_LEVEL
    _TOP_LEVEL.destroy()
    _TOP_LEVEL = None
    rospy.signal_shutdown("Kill GUI")

## Record Tab ###
#
## Documentation for the manual() method.
#
#  Handles the button click event of the manual record button and publishes
#  the event topic
def manual():
    rec_name = _UI.ent_rec_name.get().strip()
    if not rec_name:
        rec_name = "manual"
    event = Event()
    event.header.stamp = rospy.Time.now()
    event.eventID = "button press"
    event.eventType = "manual record"
    event.dynamicRecord = False
    event.shadowRecord = False
    event.alertMsg = rec_name
    _PUB.publish(event)

## Documentation for the shadow() method
#
#  Handles the button click event of the shadow record button and publishes
#  the event topic
def shadow():
    event = Event()
    event.header.stamp = rospy.Time.now()
    event.eventID = "button press"
    event.eventType = "shadow record"
    event.dynamicRecord = False
    event.shadowRecord = False
    event.alertMsg = "Shadow record captured!"
    _PUB.publish(event)

## Documentation for the poll() method
#
#  Refreshes the list of captures within the given window of the GUI.
def poll():
    store_y_location = _UI.directory_of_bags_scroll.yview()
    input_path()
    _UI.directory_of_bags_scroll.update_idletasks()
    # Refresh Rate of 100 ms
    _UI.directory_of_bags_scroll.yview_moveto(store_y_location[0])
    _UI.directory_of_bags_scroll.after(10000, poll)

## Documentation for the input_kml_filename() method
#
#  Gets the current kml being used by ddr and publishes it to a textbox
#  in the gui
def input_kml_filename():
    _UI.txtbox_active_kml.config(state='normal')
    _UI.txtbox_active_kml.delete('0', 'end')
    _UI.txtbox_active_kml.insert('end', _KML)
    _UI.txtbox_active_kml.config(state='readonly')

## View Tab ###
#
## Documentation for the get_filenames() function
#
#  Returns sorted list of captures in the target directory
def get_filenames():
    return sorted([filename for filename in os.listdir(_PATH_OF_BAGS)
                   if os.path.isdir(os.path.join(_PATH_OF_BAGS, filename))])

## Documentation for the insert_list() method
#
#  Displays captures into the directory_of_bags_scroll scrollable list in the
#  GUI
def insert_list():
    global _LIST_OF_CAPTURES
    _LIST_OF_CAPTURES = get_filenames()
    for item in _LIST_OF_CAPTURES:
        _UI.directory_of_bags_scroll.insert('end', item)

## Documentation ofr the clear_list() method
#
#  Clears the directory_of_bags_scroll, scrollable list in the GUI
def clear_list():
    global _UI
    _UI.directory_of_bags_scroll.delete('0', 'end')

## Documentation for the input_path() method
#
#  Method checks if the capture folder location is a directory and if it is,
#  clears the directory_of_bags_scroll scrollable list and updates the list with
#  any new captures
def input_path():
    global _PATH_OF_BAGS
    _PATH_OF_BAGS = os.path.dirname(str(_DDR_DIR) + '/')
    if os.path.isdir(_PATH_OF_BAGS):
        clear_list()
        insert_list()
    else:
        print("Error! Path is not a real directory.")

## Documentation for the on_enter() method
#
# The index of the mouse click selected capture in the directory_of_bags_scroll
# scrollable list is used to lookup the selected capture. Once found, an error
# check is made to ensure the markdown file has been generated. If it has been
# generated, the markdown is displayed in the textbox adjacent to the scrollable
# list. If the markdown generation is not yet complete a status message is
# displayed.
def on_enter(event):
    global _UI
    try:
        capture_folder = _UI.directory_of_bags_scroll.get(
            _UI.directory_of_bags_scroll.curselection()[0])
        markdown_file = capture_folder + "_report.md"
        _UI.markdown_viewer.delete('0', 'end')
    except IndexError:
        pass
    else:
        try:
            info_dict = open(_PATH_OF_BAGS  + '/' + capture_folder +
                             '/' + markdown_file)
        except IOError:
            _UI.markdown_viewer.insert('end', "markdown gen in progress")
        else:
            markdown_list = str(info_dict.read()).split('\n')
            for mdf in markdown_list:
                _UI.markdown_viewer.insert('end', mdf)

## Delete Tab ###
#
## Documentation for the refresh_records() method
#
#  When the refresh button is pressed, the displayed list of captures is first
#  deleted and then refreshed with all captures that have completed copying and
#  their respective markdowns written.
def refresh_records():
    _UI.dir_of_bags_scroll_copy.delete(0, 'end')
    for item in _LIST_OF_CAPTURES:
        entries = os.scandir(_PATH_OF_BAGS  + '/' + item)
        for entry in entries:
            if entry.name.endswith('.md'):
                _UI.dir_of_bags_scroll_copy.insert('end', item)

## Documentation for the delete_records() method
#
#  After click selecting files for deletion and then pressing the delete button,
#  a message box will pop up requesting confirmation that the selected files be
#  permanentaly deleted from the captures directory. If confirmed, the selected
#  files will permanently be removed from disk.
def delete_records():
    msg_box = messagebox.askquestion('Are you sure?', "Selecting 'Yes' will\
                                     permanently delete the selected files",
                                     icon='warning')
    if msg_box == 'yes':
        selected_index = _UI.dir_of_bags_scroll_copy.curselection()
        for index in selected_index[::-1]:
            selected_file = _UI.dir_of_bags_scroll_copy.get(index, last=None)
            file_path = _PATH_OF_BAGS  + '/' + selected_file
            _LIST_OF_CAPTURES.remove(selected_file)
            _UI.directory_of_bags_scroll.delete(index, last=None)
            _UI.dir_of_bags_scroll_copy.delete(index, last=None)
            shutil.rmtree(file_path)
        _UI.markdown_viewer.delete(0, 'end')

## KML Publisher Tab
#
#  Definition of populate the list of mode scrollbox
#
#  This method calls a method that will return a dictionary
#  this dictionary will then be parsed and added to the scrollbox
#  the key will before the colon and teh value will be after semi colon
#  eg. topicGroup:Idle
def populate_all_modes_scrollbox():
    #get the dictionary
    #temp_dict = _TP.get_group_list_dictionary()
    temp_dict = {"0":"hello", "1":"Hi", "2":"Hola"}
    #loops through dict
    for mode in temp_dict:
        #if the length of the value for a certain
        #key is grater than zero
        if len(temp_dict[mode]) > 0:
            #sets the key:value as strig o input to the end of
            #the list in the scrollbox
            for value in temp_dict[mode]:
                _UI.all_mode_scroll_lb.insert("end", str(mode) + ":"+str(value))
        else:
            #if not then it will just insert key: to the scrollbox
            _UI.all_mode_scroll_lb.insert("end", str(mode) + ":")

## Documentation for remove_btn_click method
#
#  The remove button will take selected modes from active modes scrollbox
#  and transfer it to the all modes scrollbox
#
#  will take the selected modes and append them to the end of the list
#  in the all modes scrollbox. I will also set the status button to red
#  to indicate that it an entry was added to the all modes scrollbox
def remove_btn_click():
    selected_mode_indexes = _UI.active_modes_scroll_lb.curselection()
    for index in selected_mode_indexes[::-1]:
        # add to a string to be published

        mode_name = _UI.active_modes_scroll_lb.get(index, last=None)
        _UI.all_mode_scroll_lb.insert("end", mode_name)
        _UI.active_modes_scroll_lb.delete(index, last=None)
        _UI.btn_submit_status.configure(bg="red")


## Documentation for submit_btn_click method
#
#  will publish dictionary that contains the status of modes
#
#  Will take all modes in each scroll box will perform
#  concatination on the string it will ben creat a key
#  with the first part of the dictionary and then it will
#  fill in the values with the second part of the string
#  depending on which list it is it will append a +/-
#  beofre the value added which that will be used to determine
#  the status of the mode
#  If the string does n ot have a secondary part
#  it will set the key as a value and will also append a +/-
#  depending in which scrollbox it is in
def submit_btn_click():
    index_num_list1 = _UI.all_mode_scroll_lb.index("end")
    index1 = 0
    temp1 = {}
    # loops through the all mode scrollbox and will create a dictionary
    # from the list, will add - to the value to indicate those entries
    # are not active.
    while index1 < index_num_list1:
        mode_name = _UI.all_mode_scroll_lb.get(index1, last=None)
        key, value = mode_name.split(":")
        if not temp1.get(key):
            temp1[key] = []
        if len(value) > 0:
            temp1[key].append("-{}".format(value))
        else:
            temp1[key].append("-{}".format(key))
        index1 += 1
    # does the same as the last loop but will add +
    # to indicate active entries
    index_num_list2 = _UI.active_modes_scroll_lb.index("end")
    index2 = 0
    while index2 < index_num_list2:
        mode_name = _UI.active_modes_scroll_lb.get(index2, last=None)
        key, value = mode_name.split(":")
        if not temp1.get(key):
            temp1[key] = []
        if len(value) > 0:
            temp1[key].append("+{}".format(value))
        else:
            temp1[key].append("+{}".format(key))
        index2 += 1
    # set the global dictionary value to be used when
    # submit button is pressed, will repopulate with
    # last good state
    for item in temp1:
        _SUBMIT_DICT[item] = temp1[item]
    # converts dicitonary into json to publish
    # that on the appropriate topic
    json_dict = json.dumps(temp1)
    _UI.btn_submit_status.configure(bg="green")
    msg = String()
    msg.data = json_dict
    _PUB3.publish(msg)

## Documentation for add_btn method
#
#  The add button will take selected modes from all modes scrollbox
#  and transfer it to the active modes scrollbox
#
#  will take the selected modes and append them to the end of the list
#  in the active mode scrollbox. I will also set the status button to red
#  to indicate that it an entry was added to the active mode scrollbox
def add_btn_click():
    #returns a list of selected indexes
    selected_mode_indexes = _UI.all_mode_scroll_lb.curselection()

    #loops though the indexes and insert the mode_name to the list
    for index in selected_mode_indexes[::-1]:
        #gets the momde name form scrollbox
        mode_name = _UI.all_mode_scroll_lb.get(index, last=None)
        _UI.active_modes_scroll_lb.insert("end", mode_name)
        _UI.all_mode_scroll_lb.delete(index, last=None)

    #switches the color to red
    _UI.btn_submit_status.configure(bg="red")

## Documentation for the reset_button_click method
#
#  Will reset the window view to last good publish state
#
#  Takes the dictionary with state infromation and populates the
#  scrollboxes corresponding to the state of the last good state
def reset_btn_click():
    # will check if dictionary is not empty, this prevent from
    # clearing the scrollboxes if you hit reset and the dictionary
    # was empty, which would just clear scrollboxes but would not
    # repopulate because it used the dictionary to repopulate
    if len(_SUBMIT_DICT) > 0:
        # deletes all entries in scrollboxes
        _UI.all_mode_scroll_lb.delete(0, 'end')
        _UI.active_modes_scroll_lb.delete(0, 'end')
        # wil loop through the dictionary and will input
        # entries into the apprpriate boxes
        for mode in _SUBMIT_DICT:
            list1 = _SUBMIT_DICT[mode]
            for item in list1:
                if item[0] is "+":
                    if item[1:] != mode:
                        _UI.active_modes_scroll_lb.insert("end", str(mode) \
                            + ":"+str(item[1:]))
                    else:
                        _UI.active_modes_scroll_lb.insert("end", str(mode)+ ":")
                elif item[0] is "-":
                    if item[1:] != mode:
                        _UI.all_mode_scroll_lb.insert("end", str(mode) \
                            + ":"+str(item[1:]))
                    else:
                        _UI.all_mode_scroll_lb.insert("end", str(mode) + ":")

        #switches the color to rgreen
        _UI.btn_submit_status.configure(bg="green")

## Mileage Tab ###
#
## Documentation for the start_mileage_ctr() method
#
#  The speed display is enabled by default and shows the current vehicle speed.
#
#  By default, the distance tracker is started when DDR launches and is
#  disabled. If the stop or reset button has been pressed, the start button will
#  become enabled allowing for continued distance recording. Method publishes a
#  message subscribed by mileage.py which calculates and publishes the distance
#  traveled.
def start_mileage_ctr():
    msg = String()
    msg.data = "start"
    _PUB1.publish(msg)
    _UI.btn_start_ctr.config(state="disabled")
    _UI.btn_stop_ctr.config(state="normal")
    _UI.btn_reset_ctr.config(state="normal")

## Documentation for the stop_mileage_ctr() method
#
#  Pressing the stop button will cause the accumulated distance to stop
#  updating. If the start button is pressed after pressing the stop button, then
#  the distance will again begin accumulating from the point the start button
#  was pressed. Method publishes a message subscribed by mileage.py which
#  calculates and publishes the distance traveled.
def stop_mileage_ctr():
    msg = String()
    msg.data = "stop"
    _PUB1.publish(msg)
    _UI.btn_start_ctr.config(state="normal")
    _UI.btn_stop_ctr.config(state="disabled")
    _UI.btn_reset_ctr.config(state="normal")

## Documentation for the reset_mileage_ctr() method
#
#  Pressing the reset button causes the displayed distance traveled to be 0.0km.
#  This method publishes a 'reset' message which is subscribed to by mileage.py.
#  Mileage.py resets the distanced traveled to 0.0 and publishes this distance.
#  If the start button is pressed, then the accumulated distance is calculated
#  and displayed from the time the start button was pressed.
def reset_mileage_ctr():
    msg = String()
    msg.data = "reset"
    _PUB1.publish(msg)
    _UI.btn_start_ctr.config(state="normal")
    _UI.btn_stop_ctr.config(state="disabled")
    _UI.btn_reset_ctr.config(state="disabled")

## Health Tab ###
#
## Documentation for the initialize_tree_view() method
#
#  Method sets the font, text, column width and default background colors of
#  the treeview widget in the GUI
def initialize_tree_view():
    style = ttk.Style()
    style.configure("Treeview.Heading", font=('DejaVu Sans', 12, 'bold'))
    _UI.health_scrolled_treeview.heading("#0", text="Topics")
    _UI.health_scrolled_treeview.column("#0", width="466")
    _UI.health_scrolled_treeview.heading("expectedHz", text="Expected Hz")
    _UI.health_scrolled_treeview.column("expectedHz", width="125",
                                        anchor='center')
    _UI.health_scrolled_treeview.heading("actualHz", text="Actual Hz")
    _UI.health_scrolled_treeview.column("actualHz", width="125",
                                        anchor='center')
    _UI.not_found_canvas.configure(bg=_HEALTH_TOPIC_NOT_FOUND)
    _UI.invalid_canvas.configure(bg=_HEALTH_TOPIC_INVALID)
    _UI.valid_canvas.configure(bg=_HEALTH_TOPIC_VALID)

## Versioning Tab ###
#
## Documentation for the publish_versioing() method
#
#  Method collects relevant data from the versioning tab of the gui
#  and converts into a .json file, then publishes this information
#  on the topic '/ddr/rg/software_versions' once every 4 seconds
#  Method also updates the current kml being used and displays this
#  in the gui
def publish_versioning_and_time():
    global _KML
    global _AUTONOMY_VERSION
    global _UI_ONE_VERSION
    global _UI_TWO_VERSION
    global _VERSIONS
    global _VENDOR

    while True:
        time.sleep(1)
        _KML = rospy.get_param("topicXML")
        input_kml_filename()
        _AUTONOMY_VERSION = _UI.entry_autonomy_version.get()
        _UI_ONE_VERSION = _UI.entry_ui_one_version.get()
        _UI_TWO_VERSION = _UI.entry_ui_two_version.get()
        _VENDOR = _UI.entry_vendor.get()
        _VERSIONS = {
            "autonomy_version": _AUTONOMY_VERSION, "ui_one_version": _UI_ONE_VERSION,
            "ui_two_version": _UI_TWO_VERSION, "vendor": _VENDOR
        }
        versions_json = json.dumps(_VERSIONS)
        #rospy.loginfo(versions_json)
        _PUB2.publish(versions_json)

        for key in CURR_TIME_DICT.keys():
            _UI.current_time_lbl.config(text=str(CURR_TIME_DICT[key]))

## Hotkeys Tab ###
# this function will update the current time
# everytime it loops
def update_curr_time(curr_time_dict):
    while not rospy.is_shutdown():
        #will update dictionary with current time
        today = datetime.date.today()
        curr_time_dict['curr_time'] = strftime('%H:%M:%S %p') + \
            ' ' + today.strftime('%m/%d/%Y')
        time.sleep(1)

##
# When the lock button is clicked it will take the current
# time and it will set the locked time dictionary
def btn_lock_click():
    for key in CURR_TIME_DICT.keys():
        LOCKED_TIME[key] = CURR_TIME_DICT[key]
        _UI.locked_time_lbl.config(text=str(LOCKED_TIME[key]))
##
# populates the scroll box with events
def populate_hot_key_events():
    # get curr dir to open the ddr_ui_hotkeys_config.txt file that contains the
    # events in there reads them and populates the scroll box
    dir_path = os.path.dirname(os.path.realpath(__file__))
    file_dir = open(dir_path+"/ddr_ui_hotkeys_config.txt", "r")
    file_input = file_dir.read()
    file_input_list = file_input.split('\n')
    while '' in file_input_list:
        file_input_list.remove('')
    for event1 in file_input_list:
        _UI.all_events_lb.insert('end', event1)
##
# Will publish msgs with time and events
# uses acquired time and then acquired the events
# by taking the slected events creates a msgs that ir publishes
# it will also only publish unless there is a selected event
# and will use current time if now locked time has been selected
def btn_publish_click():
    global LOCKED_TIME
    msg = String()
    # check if see if a Locked Time has been selected
    # it will do this by chcking if the dLocked dictionary
    # has a key, if it does not it means the locked
    # buttons has not been cliked as to set the locked time
    if len(LOCKED_TIME.keys()) > 0:
        #if it has it starts to create the msg that it will
        #publish and uses the locked time val
        key = LOCKED_TIME.keys()
        msg.data = LOCKED_TIME[key[0]] + ', '
    else:
        # if a locked time has not been set
        # then it will use the curr time
        # to start creating the msg that it will publish
        key = CURR_TIME_DICT.keys()
        msg.data = CURR_TIME_DICT[key[0]] + ', '

    #returns a list of selected indexes
    # these are the indexes that pertain to the event the user
    # has chosen
    selected_mode_indexes = _UI.all_events_lb.curselection()

    #loops though the indexes and insert the mode_name to the list
    for index in selected_mode_indexes[::-1]:
        msg.data += _UI.all_events_lb.get(index, last=None) + ', '

    msg.data = msg.data[:-2]
    # checks if the user has selcted any
    # event to actually publish the event
    if len(selected_mode_indexes) > 0:
        _PUB4.publish(msg)
    #resets the locked time val/label, and selected index
    manager = Manager()
    LOCKED_TIME = manager.dict()
    _UI.all_events_lb.selection_clear(0, 'end')
    _UI.locked_time_lbl.config(text=str('Locked Time'))


## Documentation for the alert_callback(data) method
#
#  Callback function that subscribes to ddr/event and updates the
#  background color of the manual record button in the record tab if a
#  manual recording has started/stopped.
#  Method also updates and displays events in the alert message window
def alert_callback(data):
    # display the time the messaged arrived
    # /ddr/event has no header file to pull the time when the message was
    # published. This is no longer true.
    # TODO: update code to use timestamp in header file
    formatted_time = datetime.datetime.utcfromtimestamp\
        (rospy.get_time()).strftime('%b %d, %Y %H:%M:%S.%f')
    if data.eventID == "button press response":
        if data.alertMsg == "Manual record started!":
            _UI.btn_manual.configure(background="red")
            _UI.btn_manual.configure(activebackground="firebrick1")
        elif data.alertMsg == "Manual record stopped!":
            _UI.btn_manual.configure(background="#d9d9d9")
            _UI.btn_manual.configure(activebackground="#f9f9f9")
        _UI.txt_alerts.insert('end', str(formatted_time) +
                              "    " + data.alertMsg)
    if data.eventID != "button press response" and data.eventID !=\
       "button press":
        if data.alertMsg != "":
            _UI.txt_alerts.insert('end', str(formatted_time) + "    " +
                                  data.alertMsg)

## Documentation for the topic_viewer_callback(data) method
#
#  Callback function that subscribes to ddr/event and displays in the
#  Topics tab of the GUI, all the current topics being recorded and also
#  the list of all possible topics that can be recorded
#  If a topicGroup change has occurred, then the TopicParser class
#  functions get_superset() and get_final_topics() are called to get the
#  lists of all topics and the list of current topics being recorded.
def topic_viewer_callback(data):
    if data.eventID == 'topicGroup':
        _TP.conditions[data.eventID] = str(data.eventType)
        _TP.processGroupsNode()
        _TP.finalizeTopics()
        topic_list = _TP.getFinalTopics()
        if isinstance(topic_list, str):
            topic_list = topic_list.split(sep=' ')
        # this gives the superset of all possible topics
        superset = _TP.getSuperset()

        _UI.active_topics_scroll_lb.delete(0, 'end')
        for topic in sorted(topic_list):
            _UI.active_topics_scroll_lb.insert('end', topic)

        _UI.all_topics_scroll_lb.delete(0, 'end')
        for topic in sorted(superset):
            _UI.all_topics_scroll_lb.insert('end', topic)

## Documentation for the mileage_callback(msg) method
#
#  Method subscribes to /ddr/mileage_counter and updates the distance traveled
#  label in the Mileage tab of the GUI
def mileage_callback(msg):
    _UI.dist_counter_label.configure(text=msg.data + " km")

## Documentation for the speed_callback(msg) method
#
#  Method subscribes to /ddr/vehicle_speed and updates the current vehicle speed
#  label in the Mileage tab of the GUI
def speed_callback(msg):
    _UI.speed_label.configure(text=msg.data + " km/hr")

## Documentation for the topic_status_callback(msg) method
#
#  Method subscribes to /ddr/topic_status and adds new health topics, values and
#  adjusts the background color to reflect the health status in the treeview of
#  the Health tab of the GUI. It also updates the values of currently monitored
#  topics and updates the background color to reflect the current health status
def topic_status_callback(msg):
    if msg.status == "Not found":
        bkgrnd = _HEALTH_TOPIC_NOT_FOUND
    elif msg.status == "Valid":
        bkgrnd = _HEALTH_TOPIC_VALID
    elif msg.status == "Invalid":
        bkgrnd = _HEALTH_TOPIC_INVALID

    if msg.topicName not in _HEALTH_TOPICS:
        _HEALTH_TOPICS.append(msg.topicName)
        health_topics = sorted(_HEALTH_TOPICS)
        ind = health_topics.index(msg.topicName)
        _UI.health_scrolled_treeview.insert("", ind, msg.topicName,
                                            text=msg.topicName,
                                            values=(msg.expected, msg.actual),
                                            tags=bkgrnd)
        _UI.health_scrolled_treeview.tag_configure(bkgrnd, background=bkgrnd)
    elif msg.topicName in _HEALTH_TOPICS:
        _UI.health_scrolled_treeview.item(msg.topicName, text=msg.topicName,
                                          values=(msg.expected, msg.actual),
                                          tags=bkgrnd)
        _UI.health_scrolled_treeview.tag_configure(bkgrnd, background=bkgrnd)

## Documentation for the topic_update_callback(msg) method
#
#  Method subscribes to /ddr/topic_updated and displays health updates in the
#  health alerts window of the GUI
def topic_update_callback(msg):
    formatted_time = datetime.datetime.utcfromtimestamp\
        (rospy.get_time()).strftime('%b %d, %Y %H:%M:%S.%f')
    _UI.health_alerts.insert('end', str(formatted_time) + "    " +
                             msg.topicName + "    " + msg.status)

## Documentation for the listener() method
#
#  Driver fucntion to all of the ROS objects that the GUI listens to
#  while loop runs until the node is shutdown, which is signaled in killGUI()
#  and called from the gui_support.py file when the user closes the gui by
#  pressing the 'X' button
def listener():
    global CURR_TIME
    while not rospy.is_shutdown():
        # setting disable_signals=True allows for node to be shutdown by calling
        # rospy.signal_shutdown('reason')
        rospy.init_node('ddr_gui', anonymous=False, disable_signals=True)
        rospy.Subscriber("ddr/event", Event, alert_callback)
        rospy.Subscriber("ddr/event", Event, topic_viewer_callback)
        rospy.Subscriber("/ddr/mileage_counter", String, mileage_callback)
        rospy.Subscriber("/ddr/vehicle_speed", String, speed_callback)
        rospy.Subscriber("/ddr/topic_status", TopicStatus,
                         topic_status_callback)
        rospy.Subscriber("/ddr/topic_updated", TopicsUpdate,
                         topic_update_callback)
        publish_versioning_and_time()
        rospy.spin()

def main():
    thread1 = threading.Thread(target=gui.vp_start_gui)
    thread1.daemon = True
    thread1.start()

if __name__ == '__main__':
    main()
